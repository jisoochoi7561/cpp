# 참조자 (레퍼런스)

## 참조자란

```
int& another_a = a;
```

another_a는 a의 또 다른 이름이라는 뜻.

## 함수인자로 레퍼런스를 받는다는 것.

```cpp
#include <iostream>

int change_val(int &p) {
  p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(number);
  std::cout << number << std::endl;
}

//결과  :  a가 3으로 바뀐다.
```

만약 여기서 int p로 받았다면

int p = a(값 복사)

따라서 매개변수 p의값만 3으로 바뀌기 때문에 a의 변환이 일어나지 않는다.



int *p로 받았다면

int *p = &number

*p로 포인터가 가리키는 것을 지정해줘야 한다.그리고 number가 아니라 &number를 넣어야 한다.



int &p의 경우야말로

int &p = a(p는 a의 또 다른 이름)

p= 3(a=3와 정확히 일치)이 동작한다.



따라서 정리하자면

만약 매개변수가 그냥 타입이라면

그것의 복사가 일어나고

거기에 연산이 된다.

a = foo(b)처럼 다른 변수에 리턴해주면 잘 쓸 수 있겠지만

안그러면 증발하고, 받은 인자에 영향도 끼치지 못한다.



포인터는 이것이 해결되지만, 계속 *를 생각해줘야 하는 부분이 있다.

레퍼런스로 받는다면, 받은 인자에 대해 직접 연산을 할 수 있다.마치 함수밖에서 하듯이..



## 상수의 참조자

상수의 참조자는 만들 수 없다.

상수의 '다른이름'을 a라고 하자.(int& a = 3)

그럼 a=4같은 연산을 할 것이다.

근데 3=4라는 연산은 말도 안되는 것이다.

따라서 상수의 참조자는 없다.

다만 '다른이름'역시 변수가 아니라면 가능하다.

const int&a = 3 은 가능하다.

그러면 b=a+1같은 연산이 가능할 것이다.

하지만 굳이 이렇게 할 상황이 있을까 싶다.



## 레퍼런스 배열

레퍼런스는 보통 메모리에 공간을 차지하지 않고(그냥 별명일 뿐) 있어서 배열로 만들 수 없다.

언어적으로 불가능하고 금지되어있다.



##  배열의 래퍼런스

```cpp
 int arr[3] = {1, 2, 3};
  int(&ref)[3] = arr;
```

## 레퍼런스를 리턴한다는 것

지역변수는 함수가 끝날 떄 사라진다.

```cpp
int foo(){
	int a = 0;
    return a;}
int main(){
    print(a); //a는 없어져있어서 이코드는 오류
    int b = foo(); //이것은 값을 리턴받아서 b=0이다
}


```



```cpp
int& foo(){
	int a = 0;
    return a;} //int& ref = a; return ref;
int main(){
    print(a); //a는 없어져있어서 이코드는 오류
    int &b = foo(); //이것은 이름을 리턴받아서 b는 a의 또 다른 이름이지만 a 가 없으므로 이것역시 오류이다 //&b = ref
}
```

이런 상황을 dangling이라 한다. 레퍼런스의 본체가 사라진 경우.

즉 지역변수는 레퍼런스리턴에 적합하지 않다는 것을 알 수 있다.



```cpp
int& function(int& a) {
    //int& a = 인자로 받는 것
  a = 5; //a=5
  return a; //return 인자로 받은 것의 레퍼런스
}

int main() {
  int b = 2;
  int c = function(b);//c=a(b의 레퍼런스) 즉 b. 따라서 c=b,즉 c=2임.
  return 0;
}
```

이 코드는 문제 없다.